--import Colyseus client
local ColyseusClient = require "colyseus.client"
local cardNamesModule = require "modules.card"  
local zonesModule = require "modules.zones"
local playersModule = require "modules.player"
local cardDataModule = require "modules.cardData"
local turnActionsModule = require "modules.turnActions"

local client
local room
local opponentCards = {}
local gameManager = "/gameManager#gameManager"

-- Connects to the Colyseus server and initializes the game room.
function init(self)
	local BASE_CORE_URL = "wss://ca-yto-4b1a817c.colyseus.cloud:443"
	client = ColyseusClient.new(BASE_CORE_URL)

	client:join_or_create("my_room", {}, handleRoomCreation)
end

-- Callback function to handle the game room creation.
function handleRoomCreation(err, _room)
	if err then
		print("JOIN ERROR: " ..err)
		return
	end

	print("JOIN SUCCESSFUL")
	room = _room

	room:on_message("server-message", function(message)
		print("Server message: " ..message)
	end)

	room:on_message("game-message", handleGameMessage)
end

-- Callback function to handle game messages received from the server.
function handleGameMessage(message)
	print("Game message:")
	for k, v in pairs(message) do
		print(k, v)
	end
	if message.action == "draw" then
		--print("This Players Name is: ", message.player_id)
		playersModule.set_oppId(message.player_id)
		opponent_drawhand()
	elseif message.action == "drop" then
		print('card object: ', message.playedCard)

		local receivedCard = {
			name = message.cardName,
			power = message.cardPower,
			cost = message.cardCost
		}
		print ('		recieved', receivedCard)
		print ('		recieved', message.cardName)
		
		opponent_drop(message.zone, receivedCard)
	elseif message.action == "end_turn" then
		print(' opp ending turn')
		turnActionsModule.oppEndTurn()
	end
end

-- Creates an opponent card in the dropzone at the correct position and updates game manager.

function opponent_drop(zone, playedCard)
	print('card object: ', playedCard)

	local cardsInDropZone = go.get(gameManager, "cardsInZone" .. zone) -- Use the zone to index the property
	local zPos = go.get(gameManager, "zPosition")
	local p = vmath.vector3(550 + ((zone-1)*300) + (cardsInDropZone * 50), 896, zPos)

	go.set(gameManager, "cardsInZone" .. zone, cardsInDropZone + 1) -- Increment the number of cards in the relevant zone

	local cardGO = factory.create("/spawner#playerCardFactory", p, nil, nil, 0.3)

	cardDataModule.add_opponent_card(playedCard)	
	table.insert(cardDataModule.deck, playedCard)	
	cardDataModule.cards[tostring(cardGO)] = playedCard 

	print("Creating card with name:", playedCard.name)
	msg.post(cardGO, "set_name", {name = playedCard.name})
	msg.post(cardGO, "set_cost", {cost = playedCard.cost})
	msg.post(cardGO, "set_power", {power = playedCard.power})
	
	print ("opponent ", playersModule.get_oppId(), " played a card in zone ", zone, ".")
	print ("Card Name: ", playedCard.name)
	print ("Card Cost: ", playedCard.cost)
	print ("Card Power: ", playedCard.power)
	print('Cards in Zone ', zone, ': ', go.get(gameManager, "cardsInZone" .. zone))

	-- Add the card to the zone
	zonesModule.add_opp_card(zone, tostring(cardGO))	
	zonesModule.refresh_zone_tile_power()	

	go.set(gameManager, "zPosition", (zPos + 0.01))

	local cardsInOpponentHand = go.get(gameManager, "cardsInOpponentHand")


	if cardsInOpponentHand > 0 then
		go.delete(opponentCards[cardsInOpponentHand])
		table.remove(opponentCards, cardsInOpponentHand)
		go.set(gameManager, "cardsInOpponentHand", table.getn(opponentCards))
	end

end

-- Creates opponent cards and updates game manager.
function opponent_drawhand()
	for i = 1,5 do
		local card = factory.create("/spawner#opponentCardBackFactory", vmath.vector3(610 + (i * 50), 1210, 0), nil, nil, 0.3)
		table.insert(opponentCards, card)
		go.set(gameManager, "cardsInOpponentHand", table.getn(opponentCards))
	end
	print ("opponent ", playersModule.get_oppId(), " drew")
end

-- Sends a message to the server when cards are drawn or played.
function on_message(self, message_id, message, sender)
	if message_id == hash("draw") then
		room:send("game-message", {action="draw", player_id=message.player_id})
		print("Cards drawn by player ", message.player_id)
	elseif message_id == hash("drop") then
		room:send("game-message", {action="drop", player_id=message.player_id, zone=message.zone, cardName=message.cardName, cardCost=message.cardCost, cardPower=message.cardPower})
		print(message.cardName," card dropped by player ", message.player_id)
		--print("Card dropped by player ", message.player_id)
	elseif message_id == hash("end_turn") then
		room:send("game-message", {action="end_turn", player_id=message.player_id})
		print("End turn by player ", message.player_id)
	end
end