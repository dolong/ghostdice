-- This script handles the interactions and behaviors for the game's cards.

local cursor = require "in.cursor"
local cardNamesModule = require "modules.card"

local gameManager = "/gameManager#gameManager"
local canDragCard = false
local isZooming = false
local zoomedCard
local dropzoneIdsToZoneNumber = {
	[hash("/dropzone")] = 1,
	[hash("/dropzone1")] = 2,
	[hash("/dropzone2")] = 3
}

-- This function initializes the script. It handles acquiring input focus and listens for cursor drag input.
function init(self)
	if not go.get("#cursor", "acquire_input_focus") then
		self.forward_input = true
		msg.post(".", "acquire_input_focus")
	end

	cursor.listen(msg.url("#cursor"), cursor.DRAG_START, function (message_id, message)
		if message.group == hash("playerCard") or message.group == hash("opponentCard") then
			if canDragCard == false then
				return true
			end
			print("Dragging a card!")
		elseif message.group == hash("dropzone") then
			return true
		end
	end)
end

-- This function forwards user input to the cursor script.
function on_input(self, action_id, action)
	if self.forward_input then
		msg.post("#cursor", "input", { action_id = action_id, action = action })
	end
end

-- This function handles incoming messages and user interactions with the cards.
function on_message(self, message_id, message, sender)
	if message_id == cursor.OVER then
		handleCursorOver(self, message)
	elseif message_id == cursor.OUT then
		handleCursorOut(self, message)
	elseif message_id == cursor.PRESSED then
		handleCursorPressed(self, message)
	elseif message_id == cursor.RELEASED then
		handleCursorReleased(self, message)
	elseif message_id == cursor.DRAG_START then
		handleDragStart(self, message)
	elseif message_id == cursor.DRAG_END then
		handleDragEnd(self, message)
	end
end


function createZoomedCard(self, message)
	if message.group == hash("playerCard") then
		local cardName = cardNamesModule.cardNames[tostring(message.id)]  -- get card name from table
		zoomedCard = factory.create("/spawner#playerCardFactory", vmath.vector3(message.x, (message.y + 200), 0), nil, {isDraggable = true}, 1)
		msg.post(zoomedCard, "set_name", {name = cardName})
	elseif message.group == hash("opponentCard") then
		zoomedCard = factory.create("/spawner#opponentCardFactory", vmath.vector3(message.x, (message.y + 300), 1), nil, nil, 0.66)
	end
	isZooming = true
end

function deleteZoomedCard()
	if isZooming then
		go.delete(zoomedCard)
		isZooming = false
	end
end

function handleCursorOver(self, message)
	print("Cursor over", message.id, message.group, message.x, message.y)

	if message.group == hash("dropzone") then
		self.over_dropzone = true
		self.zone = dropzoneIdsToZoneNumber[message.id] or 0
		print("Cursor over dropzone ", message.id, message.group, message.x, message.y)
		print('')
	else 
		self.over_dropzone = false
		self.zone = 0
	end

	if (message.group == hash("playerCard") or message.group == hash("opponentCard")) and not isZooming then
		createZoomedCard(self, message)
	end
end

function handleCursorOut(self, message)
	if message.id == hash("dropzone") then
		self.over_dropzone = false
	end

	if (message.group == hash("playerCard") or message.group == hash("opponentCard")) then
		deleteZoomedCard()
	end
end

function setDragCard(self, message, value)
	if message.group == hash("playerCard") or message.group == hash("opponentCard") then
		local url = msg.url(message.id)
		url.fragment = "card"
		canDragCard = value
	end
end

function handleCursorPressed(self, message)
	setDragCard(self, message, go.get(msg.url(message.id, "card"), "isDraggable"))
end

function handleCursorReleased(self, message)
	setDragCard(self, message, false)
end

function handleDragStart(self, message)
	--uncomment to print("Drag started", message.id, message.group, message.x, message.y)
	--set the z position to bring the dragged card to top
	local zPos = go.get(gameManager, "zPosition")
	local p = go.get_position(message.id)
	go.set_position(vmath.vector3(p.x, p.y, zPos), message.id)
	-- increment the current zPosition in the gameManager
	go.set(gameManager, "zPosition", (zPos + 0.01))
end

function handleDragEnd(self, message)
	--uncomment to 
	print("Drag ended", message.id, message.group, message.x, message.y)
	--incrementally display cards over dropzone
	if (message.group == hash("playerCard") or message.group == hash("opponentCard")) and self.over_dropzone then
		print('dropped in dropzone')
		local cardsInDropZone = go.get(gameManager, "cardsPlayed")
		local zPos = go.get(gameManager, "zPosition")
		local p = vmath.vector3(550 +  ((self.zone-1)*300)+(cardsInDropZone*20), 400, zPos)
		go.set_position(p, message.id)

		local new_scale = vmath.vector3(0.25, 0.25, 1)  -- half the size in x and y, unchanged in z
		go.set_scale(new_scale, message.id)

		--make cards not be able to be dragged once dropped
		local url = msg.url(message.id)
		url.fragment = "card"
		go.set(url, "isDraggable", false)
		--increment the number of cards played and the zPosition in the gameManager
		go.set(gameManager, "cardsPlayed", (cardsInDropZone + 1))
		go.set(gameManager, "zPosition", (zPos + 0.01))
		--send a message to the client that a card has been played
		msg.post("/client#client", "drop", {player_id = self.player_id, zone = 1})

	end
end
