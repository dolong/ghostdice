local button = require "in.button"
local playersModule = require "modules.player"
local druid = require("druid.druid")
local input = require("druid.extended.input")
local progress = require("druid.extended.progress")
local timer_component = require("druid.extended.timer")
local camera = require "orthographic.camera"
local cardDataModule = require "modules.cardData"
local diceModule = require "modules.dice"
local slider = require("druid.extended.slider")

local hover_shadow_style = require("modules.hover_button")

player = "x"


local function get_query_parameters()
	if html5 then
		local url = html5.run("window.location")
		-- get the query part of the url (the bit after ?)
		local query = url:match(".*?(.*)")
		if not query then
			return {}
		end

		local params = {}
		-- iterate over all key value pairs
		for kvp in query:gmatch("([^&]+)") do
			local key, value = kvp:match("(.+)=(.+)")
			params[key] = value
		end
		return params
	else 
		return { user = "desktop" }
	end
end



local function on_button_callback(self)
	print("Start Button was clicked!")

	local text = self.battle_log:get_text()
	print(text)
	local player = playersModule.set_id(text)
	login() -- Call the login function when the button is clicked.
end



-- Utility function to compact a list and remove nil values
function compactList(list)
	local compactedList = {}
	for _, v in ipairs(list) do
		if v ~= nil then
			table.insert(compactedList, v)
		end
	end
	return compactedList
end

local function on_button_callback2(self)
	print("Search Button was clicked!")

	local text = self.battle_log:get_text()
	print(text)
	local player = playersModule.set_id(text)
	search() -- Call the search function when the button is clicked.
end


local function train(self)
	show_golem_black()
	analysis(self)
end


local function golem_speak(self, speak) 

	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, ".. I play .." .. speak)
	
end

local function golem_announce_winner(self, winner, draw) 

	local golem = gui.get_node("golemTalk")
	print (player, winner)
	if (draw == true) then
		gui.set_text(golem, ".. " .. "game is.. draw")
	elseif (player == winner) then
		gui.set_text(golem, ".. " .. "You win..")
	else 
		gui.set_text(golem, ".. " .. "I win..")
	end

end

local function golem_analysis(self, speak) 

	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, "I learn .." )
	self.battle_log:set_text(speak)	
	show_golem_thinking()
end

local function refresh(self)
	print("Refresh Button was clicked!")
	hide_golem_thinking()
	msg.post("/squares#tictactoe", "reset")
	self.battle_log:set_text("")
end

local function roll_dice_and_play_as_ai(self)
	print("Roll Dice Button was clicked!")

end


local function log_turn(self, lane_choice)

	print("logging turn")
	local currentText = self.battle_log:get_text()
	-- Add a new line if there isn't anything yet
	if string.len(currentText) > 1 then
		newText = currentText .. ",\n" 
		if (diceModule.dicePlaced) then
			parse_logs_for_chatgpt(self, "user_played", lane_choice)
		else
			parse_logs_for_chatgpt(self, "user_rolled")			
		end
	else 
		-- Init the logs
		parse_logs_for_chatgpt(self, "user_rolled")
	end

	--self.battle_log:set_text(newText)
end

function parse_logs_for_chatgpt(self, action, lane_choice)
	currentPlayer = diceModule.getCurrentPlayer()
	log = self.battle_log:get_text()
	diceNumber = diceModule.getDiceRoll()
	playerNumber = diceModule.getCurrentPlayer()
	
	if (action == "user_rolled") then
		print ("logging roll")
		log = log .. "Turn " .. diceModule.getTurn() .. ",\n" 
		log = log .. "It is now player_" .. currentPlayer .. "s" .. " turn" .. "\n"
		log = log .. "Roll Phase: player_" .. currentPlayer .. " rolls" .. " a " .. diceNumber .. "\n"
	elseif ( action == "user_played") then
		log = log .. "Lane Choice Phase: lane_choice: {'".. lane_choice .. "'}." .. "}\n" 
		log = log .. "Game Update: Your lanes are now " .. diceModule.get_player_lanes_as_string(playerNumber) .. "\n" 
		if diceModule.check_duplicate_in_opponent_player(playerNumber, diceNumber, lane_choice) then
			log = log .. "Discard Phase: I see duplicates in opponent lane_" .. lane_choice .. ", removing\n" 
			diceModule.check_duplicates_and_destroy(playerNumber, diceNumber, lane_choice)
		else
			log = log .. "Discard Phase: I donâ€™t see any matches in opponent lane_" .. lane_choice .. "\n" 
		end
				
		log = log .. "Game Update: The lanes are now " .. diceModule.get_status_as_string() .. "\n" 
		log = log .. "End Phase: player_1s turn is now over. It is now player_2s turn" .. "\n" 
		diceModule.nextTurn()
		enable_next_button(self)
	end	

	self.battle_log:set_text(log)
	print("set log to ".. log)
end

local function register_druid_extended_components(self)
	druid.register("input", input)
	druid.register("progress", progress)
	druid.register("timer", timer_component)
	-- Register the extended slider component
	druid.register("slider", slider_extension)
end


local function getCoordinates(squareId)
	local mapping = {
		["00"] = "0,0",
		["01"] = "0,1",
		["02"] = "0,2",
		["10"] = "1,0",
		["11"] = "1,1",
		["12"] = "1,2",
		["20"] = "2,0",
		["21"] = "2,1",
		["22"] = "2,2"
	}
	return mapping[squareId] or "0,0"  -- Default to "0,0" if squareId is not in the mapping
end


function init(self)

	msg.post("/sounds#background_music", "play_sound", {gain = 1.0})
	math.randomseed(os.time())  -- Seed the random number generator once
	local params = get_query_parameters() 
	local user = params.user
	
	local userid_node = gui.get_node("userid")
	
	-- Set the text
	if (user) then
		gui.set_text(userid_node, "logged in as: " .. user)
	end
	self.druid = druid.new(self)
	register_druid_extended_components(self)
	self.refreshButton = self.druid:new_button("refresh/button", refresh)	
	self.rollDiceButton = self.druid:new_button("roll_dice/button", next)	
	self.rollDiceBox = self.druid:new_button("roll_dice/box", next)	
	self.button = self.druid:new_button("golem_roll/button", ask_golem_for_move)	
	self.button = self.druid:new_button("try", show_golem_thinking)

	
	self.battle_log = self.druid:new_input("inputbox", "cardEffect")
	
	-- Bind the play_lane function with the specific node id for each button
	local custom_style1 = self.druid:new_button("select_player_1_lane1/button", function() play_lane(self, "select_player_1_lane1") end)
	custom_style1:set_style(hover_shadow_style)

	local custom_style2 = self.druid:new_button("select_player_1_lane2/button", function() play_lane(self, "select_player_1_lane2") end)
	custom_style2:set_style(hover_shadow_style)

	local custom_style3 = self.druid:new_button("select_player_1_lane3/button", function() play_lane(self, "select_player_1_lane3") end)
	custom_style3:set_style(hover_shadow_style)
	
	
	
	-- Subscribe to the on_input_select event
	--self.battle_log.on_input_select:subscribe(on_input_select, self)
end

-- using click
function play_lane(self, node_id)
	-- Extract playerNumber and lane from the node_id
	-- Assuming node_id is in the format "select_player_X_laneY"
	local pattern = "select_player_(%d+)_lane(%d+)"
	local playerNumber, lane_choice = node_id:match(pattern)

	-- Convert extracted values to numbers
	playerNumber = tonumber(playerNumber)
	lane_choice = tonumber(lane_choice)

	-- Fallback in case of invalid or missing data
	if not playerNumber or not lane_choice then
		print("Invalid node id or pattern mismatch: " .. node_id)
		return
	end

	-- Get the dice number
	local diceNumber = diceModule.getDiceRoll()

	-- Place the dice on the lane
	if (not diceModule.is_lane_full(playerNumber, lane_choice) and not diceModule.dicePlaced and not diceModule.aiRolled) then
		diceModule.place_dice_to_lane(playerNumber, diceNumber, lane_choice)
		if (diceModule.are_all_lanes_full(diceModule.getCurrentPlayer())) then
			local golem = gui.get_node("golemTalk")
			gui.set_text(golem, "That was the last move. Good Game!")			
		end
		play_dice_sound(self)
		print(lane_choice)
		log_turn(self, lane_choice)
	else
		print("Incorrect click")
	end
end

-- using AI
function ai_play_lane(self, lane_choice)

	playerNumber = diceModule.getCurrentPlayer()
	-- Get the dice number
	local diceNumber = diceModule.getDiceRoll()
	
	-- Place the dice on the lane
	diceModule.place_dice_to_lane(playerNumber, diceNumber, lane_choice)
	play_dice_sound(self)

	log_turn(self, lane_choice)
	if (diceModule.are_all_lanes_full(diceModule.getCurrentPlayer())) then
		local golem = gui.get_node("golemTalk")
		gui.set_text(golem, "That was the last move. Good Game!")			
	end
end

function play_dice_sound(self)
	-- Assuming you have a sound component called 'roll_dice_sound'
	msg.post("/sounds#dice_place_sound", "play_sound", {gain = 1.0})
end

function roll_dice_sound(self)
	-- Assuming you have a sound component called 'roll_dice_sound'
	msg.post("/sounds#roll_dice_sound", "play_sound", {gain = 1.0})
end

function randomize_dice(self, ai_play)
	local body = json.encode({dice = 1}) -- encoding data as a JSON string
	local headers = {["Content-Type"] = "application/json"} -- setting content type to json
	if (ai_play) then
		http.request("https://eo66i7canq8cf3g.m.pipedream.net", "POST", diceAIHandleResponse, headers, body)
	else 
		http.request("https://eo66i7canq8cf3g.m.pipedream.net", "POST", diceHandleResponse, headers, body)
	end
end

function replace_newlines_with_literal(str)
	-- Replace newline characters with the literal string "\n"
	return string.gsub(str, "\n", "\\n")
end

function ask_golem_for_move(self)
	full_log = self.battle_log:get_text()
	local processed_log = replace_newlines_with_literal(full_log)
	body = '[{"role": "system", "content": "' .. processed_log .. '"}]'
	
	local body = json.encode(body) -- encoding data as a JSON string
	local headers = {["Content-Type"] = "application/json"} -- setting content type to json
	http.request("https://eop5ahgi06r1qc3.m.pipedream.net", "POST", golemHandleResponse, headers, body)
end

function golemHandleResponse(self, id, response)
	if response.status == 200 then
		roll_dice_sound(self)
		local data = json.decode(response.response)
		move = json.decode(data.move)
		print(move)
		ai_play_lane(self, move)
		
		local golem = gui.get_node("golemTalk")
		
		gui.set_text(golem, gui.get_text(golem) .. "\nI'll move it here")
		
	else
		print("Error: ", response.status)
		print("Trying again")
		ask_golem_for_move(self)
	end
end


function diceAIHandleResponse(self, id, response)
	if response.status == 200 then
		roll_dice_sound(self)
		diceModule.aiRoll()
		print(diceModule.aiRolled)
		local data = json.decode(response.response)

		local rolls_array = json.decode(data.rolls)
		if #rolls_array > 0 then
			local roll_number = rolls_array[1]
			print("diceRoll:", roll_number)

			-- Call the corresponding function based on the roll number
			if roll_number == 1 then
				dice_roll_1(self)
			elseif roll_number == 2 then
				dice_roll_2(self)
			elseif roll_number == 3 then
				dice_roll_3(self)
			elseif roll_number == 4 then
				dice_roll_4(self)
			elseif roll_number == 5 then
				dice_roll_5(self)
			elseif roll_number == 6 then
				dice_roll_6(self)
			else
				print("Roll number not handled:", roll_number)
			end
			diceModule.setDice(roll_number)
			-- log the dice roll into the battle log
			local golem = gui.get_node("golemTalk")
			gui.set_text(golem, "I rolled a " .. diceModule.getDiceRoll())

			log_turn(self)
			ask_golem_for_move(self)

		else
			print("No dice roll data received.")
		end
	else
		print("Error: ", response.status)
	end
end

function diceHandleResponse(self, id, response)
	if response.status == 200 then
		roll_dice_sound(self)
		diceModule.personRoll()
		print(diceModule.aiRolled)
		local data = json.decode(response.response)
		
		local rolls_array = json.decode(data.rolls)
		if #rolls_array > 0 then
			local roll_number = rolls_array[1]
			print("diceRoll:", roll_number)
			
			-- Call the corresponding function based on the roll number
			if roll_number == 1 then
				dice_roll_1(self)
			elseif roll_number == 2 then
				dice_roll_2(self)
			elseif roll_number == 3 then
				dice_roll_3(self)
			elseif roll_number == 4 then
				dice_roll_4(self)
			elseif roll_number == 5 then
				dice_roll_5(self)
			elseif roll_number == 6 then
				dice_roll_6(self)
			else
				print("Roll number not handled:", roll_number)
			end
			diceModule.setDice(roll_number)
			-- log the dice roll into the battle log
			local golem = gui.get_node("golemTalk")
			gui.set_text(golem, "I rolled a " .. diceModule.getDiceRoll() .. "\nHmm where should I place it?")
						
			log_turn(self)
		else
			print("No dice roll data received.")
		end
	else
		print("Error: ", response.status)
	end
end


function dice_roll_1(self)
	-- Logic for dice roll 1
	print("Function for dice roll 1 called.")

	-- Prepare the message data with the dice roll value
	local message_data = { dice_roll_value = 1 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)

end

function dice_roll_2(self)
	-- Logic for dice roll 2
	print("Function for dice roll 2 called.")
	local message_data = { dice_roll_value = 2 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_3(self)
	-- Logic for dice roll 2
	print("Function for dice roll 3 called.")
	local message_data = { dice_roll_value = 3 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_4(self)
	-- Logic for dice roll 2
	print("Function for dice roll 4 called.")
	local message_data = { dice_roll_value = 4 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_5(self)
	-- Logic for dice roll 2
	print("Function for dice roll 5 called.")
	local message_data = { dice_roll_value = 5 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_6(self)
	-- Logic for dice roll 2
	print("Function for dice roll 6 called.")
	local message_data = { dice_roll_value = 6 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end
function show_golem_black()	
	msg.post("/players#golem", "show_black")
end

function roll_dice(self)	
	print('randomizing')
	
	randomize_dice(self, false)
	--msg.post("/players#golem", "roll_dice")
end



function roll_dice_and_play_as_ai(self)
	print('randomizing as ai')
	randomize_dice(self, true)
end

function next(self)
	
	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, "")
	
	if (diceModule.getCurrentPlayer() == 1) then
		local message_data = { char = "chara_portraits_batch1_monke" }
		msg.post("/players#player_portraits", "set_potrait", message_data)
		disable_next_button(self)
		roll_dice(self)
	else		
		local message_data = { char = "chara_portraits_batch1_goblin" }
		print ("goblin")
		msg.post("/players#player_portraits", "set_potrait", message_data)
		disable_next_button(self)	
		roll_dice_and_play_as_ai(self)		
	end
end
function disable_next_button(self)
	-- Disable the button
	if self.rollDiceButton then
		self.rollDiceButton:set_enabled(false)
	end
end

function enable_next_button(self)
	-- Enable the button
	if self.rollDiceButton then
		self.rollDiceButton:set_enabled(true)
	end
end

function hide_golem_thinking()	
	msg.post("/players#golem", "hide_loading")
end
function final(self)
	self.druid:final()
	-- button.unregister()
end


function on_input(self, action_id, action)
	--print("Handling input: " .. tostring(action_id))
	if action_id == hash("input_select") then
		print("selected")
		on_input_select(self, action_id, action)
	end
	return self.druid:on_input(action_id, action)
	-- button.on_input(action_id, action)
end

-- 
-- -- "update" is used in progress bar, scroll, and timer basic components
-- function update(self, dt)
-- 	self.druid:update(dt)
-- end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender) -- Druid's on_message

	if message_id == hash("proxy_loaded") then
		-- When the collection has loaded, we enable it
		msg.post(sender, "enable")

		-- And then disable the login collection
		msg.post(".", "disable")
	end
		-- other message handling...
end

