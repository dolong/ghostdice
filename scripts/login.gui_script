local button = require "in.button"
local playersModule = require "modules.player"
local druid = require("druid.druid")
local input = require("druid.extended.input")
local progress = require("druid.extended.progress")
local timer_component = require("druid.extended.timer")
local camera = require "orthographic.camera"
local cardDataModule = require "modules.cardData"
local diceModule = require "modules.dice"

local sprite_style = require("modules.hover_button")

player = "x"

local function get_query_parameters()
	if html5 then
		local url = html5.run("window.location")
		-- get the query part of the url (the bit after ?)
		local query = url:match(".*?(.*)")
		if not query then
			return {}
		end

		local params = {}
		-- iterate over all key value pairs
		for kvp in query:gmatch("([^&]+)") do
			local key, value = kvp:match("(.+)=(.+)")
			params[key] = value
		end
		return params
	else 
		return { user = "desktop" }
	end
end



local function on_button_callback(self)
	print("Start Button was clicked!")

	local text = self.battle_log:get_text()
	print(text)
	local player = playersModule.set_id(text)
	login() -- Call the login function when the button is clicked.
end



-- Utility function to compact a list and remove nil values
function compactList(list)
	local compactedList = {}
	for _, v in ipairs(list) do
		if v ~= nil then
			table.insert(compactedList, v)
		end
	end
	return compactedList
end

local function on_button_callback2(self)
	print("Search Button was clicked!")

	local text = self.battle_log:get_text()
	print(text)
	local player = playersModule.set_id(text)
	search() -- Call the search function when the button is clicked.
end


local function play_as_x(self)
	hide_golem_thinking()
	msg.post("/squares#tictactoe", "reset")
	player = "x"

	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, ".. About time.. You may go..   First..")
	self.battle_log:set_text("")
end

local function play_as_o(self)
	hide_golem_thinking()
	msg.post("/squares#tictactoe", "reset")
	player = "o"
	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, ".. This time..   I go first.. \n.. making.. the first move..")
	self.battle_log:set_text("")
	golemPlay(self)
	print("player is o")
end

local function train(self)
	show_golem_black()
	analysis(self)
end


local function golem_speak(self, speak) 

	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, ".. I play .." .. speak)
	
end

local function golem_announce_winner(self, winner, draw) 

	local golem = gui.get_node("golemTalk")
	print (player, winner)
	if (draw == true) then
		gui.set_text(golem, ".. " .. "game is.. draw")
	elseif (player == winner) then
		gui.set_text(golem, ".. " .. "You win..")
	else 
		gui.set_text(golem, ".. " .. "I win..")
	end

end

local function golem_analysis(self, speak) 

	local golem = gui.get_node("golemTalk")
	gui.set_text(golem, "I learn .." )
	self.battle_log:set_text(speak)	
	show_golem_thinking()
end

local function refresh(self)
	print("Refresh Button was clicked!")
	hide_golem_thinking()
	msg.post("/squares#tictactoe", "reset")
	self.battle_log:set_text("")
end

local function roll_dice(self)
	print("Roll Dice Button was clicked!")
	
	msg.post("/squares#tictactoe", "reset")
	self.battle_log:set_text("")
end

local function register_druid_extended_components(self)
	druid.register("input", input)
	druid.register("progress", progress)
	druid.register("timer", timer_component)
end


local function getCoordinates(squareId)
	local mapping = {
		["00"] = "0,0",
		["01"] = "0,1",
		["02"] = "0,2",
		["10"] = "1,0",
		["11"] = "1,1",
		["12"] = "1,2",
		["20"] = "2,0",
		["21"] = "2,1",
		["22"] = "2,2"
	}
	return mapping[squareId] or "0,0"  -- Default to "0,0" if squareId is not in the mapping
end

local function squareclick(self, squareId)
	local currentText = self.battle_log:get_text()

	local coords = getCoordinates(squareId)
	local newText = ""

	if currentText == "Battle Log" then
		hide_golem_thinking()
		print("Existing text")
		refresh(self)
	else
		
		if string.len(currentText) > 1 then
			newText = currentText .. ",\n" 
		end

		newText = newText .. '{ "role": "user", "content": "[' .. coords .. ']" }'

		self.battle_log:set_text(newText)

		local image

		print("player is ", player)
		if player == "x" then
			image = "x"
		else
			image = "o"
		end
		
		msg.post("/squares#tictactoe", "set_image", {image = image, square = squareId})
		golemPlay(self)
	end
end



function init(self)

	msg.post("/sounds#background_music", "play_sound", {gain = 1.0})
	math.randomseed(os.time())  -- Seed the random number generator once
	local params = get_query_parameters() 
	local user = params.user
	
	local userid_node = gui.get_node("userid")
	
	-- Set the text
	if (user) then
		gui.set_text(userid_node, "logged in as: " .. user)
	end
	self.druid = druid.new(self)
	register_druid_extended_components(self)
	self.button = self.druid:new_button("generateCard/button", play_as_x)
	self.button = self.druid:new_button("playAsO/button", play_as_o)
	self.button = self.druid:new_button("refresh/button", refresh)	
	self.button = self.druid:new_button("roll_dice/button", roll_dice)	
	self.button = self.druid:new_button("train/button", train)	
	self.button = self.druid:new_button("try", show_golem_thinking)	
	self.battle_log = self.druid:new_input("inputbox", "cardEffect")
	
	-- Bind the play_lane function with the specific node id for each button
	local custom_style1 = self.druid:new_button("select_player_1_lane1/button", function() play_lane(self, "select_player_1_lane1") end)
	custom_style1:set_style(sprite_style)

	local custom_style2 = self.druid:new_button("select_player_1_lane2/button", function() play_lane(self, "select_player_1_lane2") end)
	custom_style2:set_style(sprite_style)

	local custom_style3 = self.druid:new_button("select_player_1_lane3/button", function() play_lane(self, "select_player_1_lane3") end)
	custom_style3:set_style(sprite_style)
	
	
	local squares = {"00", "01", "02", "10", "11", "12", "20", "21", "22"}
	for _, squareId in ipairs(squares) do
		self.button = self.druid:new_button("box" .. squareId, function() squareclick(self, squareId) end)
	end
	
	-- Subscribe to the on_input_select event
	--self.battle_log.on_input_select:subscribe(on_input_select, self)
end


function play_lane(self, node_id)
	-- Extract playerNumber and lane from the node_id
	-- Assuming node_id is in the format "select_player_X_laneY"
	local pattern = "select_player_(%d+)_lane(%d+)"
	local playerNumber, lane = node_id:match(pattern)

	-- Convert extracted values to numbers
	playerNumber = tonumber(playerNumber)
	lane = tonumber(lane)

	-- Fallback in case of invalid or missing data
	if not playerNumber or not lane then
		print("Invalid node id or pattern mismatch: " .. node_id)
		return
	end

	-- Get the dice number
	local diceNumber = diceModule.getDiceRoll()

	-- Place the dice on the lane
	diceModule.place_dice_to_lane(playerNumber, diceNumber, lane)
	play_dice_sound(self)
end

function play_dice_sound(self)
	-- Assuming you have a sound component called 'roll_dice_sound'
	msg.post("/sounds#dice_place_sound", "play_sound", {gain = 1.0})
end

function roll_dice_sound(self)
	-- Assuming you have a sound component called 'roll_dice_sound'
	msg.post("/sounds#roll_dice_sound", "play_sound", {gain = 1.0})
end
function randomize_dice(self)
	local body = json.encode({dice = 1}) -- encoding data as a JSON string
	local headers = {["Content-Type"] = "application/json"} -- setting content type to json
	http.request("https://eo66i7canq8cf3g.m.pipedream.net", "POST", diceHandleResponse, headers, body)
end


function diceHandleResponse(self, id, response)
	if response.status == 200 then
		roll_dice_sound(self)
		local data = json.decode(response.response)
		
		local rolls_array = json.decode(data.rolls)
		if #rolls_array > 0 then
			local roll_number = rolls_array[1]
			print("diceRoll:", roll_number)

			
			-- Call the corresponding function based on the roll number
			if roll_number == 1 then
				dice_roll_1(self)
			elseif roll_number == 2 then
				dice_roll_2(self)
			elseif roll_number == 3 then
				dice_roll_3(self)
			elseif roll_number == 4 then
				dice_roll_4(self)
			elseif roll_number == 5 then
				dice_roll_5(self)
			elseif roll_number == 6 then
				dice_roll_6(self)
			else
				print("Roll number not handled:", roll_number)
			end
			diceModule.setDice(roll_number)
		else
			print("No dice roll data received.")
		end
	else
		print("Error: ", response.status)
	end
end

-- Example functions for dice rolls
function dice_roll_1(self)
	-- Logic for dice roll 1
	print("Function for dice roll 1 called.")

	-- Prepare the message data with the dice roll value
	local message_data = { dice_roll_value = 1 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
	
end

function dice_roll_2(self)
	-- Logic for dice roll 2
	print("Function for dice roll 2 called.")
	local message_data = { dice_roll_value = 2 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_3(self)
	-- Logic for dice roll 2
	print("Function for dice roll 3 called.")
	local message_data = { dice_roll_value = 3 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_4(self)
	-- Logic for dice roll 2
	print("Function for dice roll 4 called.")
	local message_data = { dice_roll_value = 4 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_5(self)
	-- Logic for dice roll 2
	print("Function for dice roll 5 called.")
	local message_data = { dice_roll_value = 5 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end

function dice_roll_6(self)
	-- Logic for dice roll 2
	print("Function for dice roll 6 called.")
	local message_data = { dice_roll_value = 6 }

	-- Post the message
	msg.post("/players#dice", "roll_dice", message_data)
end
function show_golem_black()	
	msg.post("/players#golem", "show_black")
end

function roll_dice()	
	print('randomizing')
	randomize_dice()
	--msg.post("/players#golem", "roll_dice")
end

function hide_golem_thinking()	
	msg.post("/players#golem", "hide_loading")
end
function final(self)
	self.druid:final()
	-- button.unregister()
end


function on_input(self, action_id, action)
	--print("Handling input: " .. tostring(action_id))
	if action_id == hash("input_select") then
		print("selected")
		on_input_select(self, action_id, action)
	end
	return self.druid:on_input(action_id, action)
	-- button.on_input(action_id, action)
end

-- 
-- -- "update" is used in progress bar, scroll, and timer basic components
-- function update(self, dt)
-- 	self.druid:update(dt)
-- end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender) -- Druid's on_message

	if message_id == hash("proxy_loaded") then
		-- When the collection has loaded, we enable it
		msg.post(sender, "enable")

		-- And then disable the login collection
		msg.post(".", "disable")
	end
end


function handleResponse(self, id, response)

	if response.status == 200 then
		local data = json.decode(response.response)
		-- You have an array 
		print("Move:", data.move)

		handleMoveResponse(self, data.move)
			-- Now 'move' is a table where move[1] is the first value and move[2] is the second value
			-- You can use these values as needed		
	else
		print("Error: ", response.status)
	end
end


function splitString(str, delimiter)
	local result = {}
	for match in (str..delimiter):gmatch("(.-)"..delimiter) do
		table.insert(result, match)
	end
	return result
end


function handleMoveResponse(self, moveString)
	local cleanedMoveString = string.lower(moveString:match("%[(.-)%]"))
	print (cleanedMoveString)
	local firstSixChars = string.sub(cleanedMoveString, 1, 6)
	-- Check for win conditions first
	if firstSixChars == "x wins" then
		print("Winner: x")
		golem_announce_winner(self,"x", false)
		return  -- Return immediately after handling the win condition
	elseif firstSixChars == "o wins" then
		print("Winner: o")
		golem_announce_winner(self,"o", false)
		return  -- Return immediately after handling the win condition
	elseif firstSixChars == "draw" then
		print("Draw")
		golem_announce_winner(self,"o", true)
		return  -- Return immediately after handling the win condition
	end
	-- Extract numbers from the string
	local x, y = moveString:match("%[(%d+),(%d+)%]")
	print (x, y)
	if x and y then
		-- Convert the extracted strings to numbers
		x = tonumber(x)
		y = tonumber(y)

		-- Convert the x, y coordinates to a squareId (e.g., "00", "11", etc.)
		local squareId = tostring(x) .. tostring(y)  -- Adjust indices to 0-based

		golem_move(self,squareId)
		-- Post a message to set the image	
		golem_speak(self, ".." .. x .. "," .. y)
	else
		print("Invalid move data:", moveString)
	end
end


function golem_move(self, squareId)
	local currentText = self.battle_log:get_text()

	local coords = getCoordinates(squareId)
	local newText = ""

	if string.len(currentText) > 1 then
		newText = currentText .. ",\n" 
	end

	newText = newText .. '{ "role": "assistant", "content": "[' .. coords .. ']" }'

	local image
	if player == "o" then
		image = "x"
	else
		image = "o"
	end
	
	msg.post("/squares#tictactoe", "set_image", {image = image, square = squareId})

	self.battle_log:set_text(newText)
	--golemPlay(self)
end

function golemPlay(self)

	local currentText = "[" .. self.battle_log:get_text() .. "]"
	
	local body = json.encode({currentMoves = currentText}) -- encoding data as a JSON string
	local headers = {["Content-Type"] = "application/json"} -- setting content type to json
	http.request("https://eo82j4aqtbngiit.m.pipedream.net", "POST", handleResponse, headers, body)
	-- go to handleResponse(self, id, response) next
end
function analysis(self)

	local currentText = "[" .. self.battle_log:get_text() .. "]"

	local body = json.encode({game = currentText}) -- encoding data as a JSON string
	local headers = {["Content-Type"] = "application/json"} -- setting content type to json
	http.request("https://eoh6tszzly87t71.m.pipedream.net", "POST", trainGolemResponse, headers, body)
	
end
function trainGolemResponse(self, id, response)

	if response.status == 200 then
		local data = json.decode(response.response)
		-- You have an array 
		print("Analysis:", data.Analysis)

		-- Now 'move' is a table where move[1] is the first value and move[2] is the second value
		-- You can use these values as needed			
		golem_analysis(self, data.Analysis)
	else
		print("Error: ", response.status)
	end
end